---
title: "fauxnaif"
author: "Alexander Rossell Hayes"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    df_print: "tibble"
vignette: >
  %\VignetteIndexEntry{fauxnaif}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Getting started

To demonstrate the basic functionality of `fauxnaif`, let's first load the package and an example dataset.

```{r}
library(fauxnaif)
fauxnaif::faux_census
```

We can see the example dataset in full above.
The data is a small section of census-like information.
This dataset needs a lot of cleaning.
Other tools like `dplyr` and `tidyr` would likely be needed to really analyze this data, but we'll focus on the aspects that can be handled by `fauxnaif`.

# The most basic case

First, let's look at the simplest issue in this dataset: income.

```{r}
faux_census$income
```

Printing the vector of incomes, one value stands out: while most respondents' have values in the tens to hundreds of thousands, two respondents have incomes of 9999999.
It's common for datasets you receive from other sources to use an unrealistically high value (often a string of 9s) to indicate `NA`.
We can clean this using `na_if()`.

```{r}
na_if(faux_census$income, 9999999)
```

The new variable has `NA`s in the place of those strings of 9s.

As an alternative, we can use the `magrittr` pipe (`%>%`) to pass an input into `na_if()`:

```{r}
faux_census$income %>% na_if(9999999)
```

This produces the same result.

This task could have been completed using the version of `na_if()` included in the `dplyr` package.
However, moving forward we will use more advanced functionality of `fauxnaif`.

# Replacing multiple values

Let's now examine the age variable:

```{r}
faux_census$age
```

In this case, we see two improbable values: 557 and 2 (assuming this is a survey of adults).
Using `dplyr`, this would have to be addressed using two steps:

```{r}
faux_census$age %>% dplyr::na_if(557) %>% dplyr::na_if(2)
```

But using `fauxnaif` we can simplify this to a single step:

```{r}
faux_census$age %>% na_if(557, 2)
```

# Specifying values to keep rather than values to discard

In the above example, we were able to examine our dataset and select the values that were unrealistic.
In real-life analyses, we often can't look at each observation one by one to find unrealistic values, but we often do know the range of realistic values.
Using `na_if_not()`, we can specify which values are realistic and discard those that are not.

Returning to the age variable, let's replace values with `NA` if they are *not* between 18 (the minimum age we expect to enter the survey) and 122 (the world record for the oldest person).

```{r}
faux_census$age %>% na_if_not(18:122)
```

This has the same effect as specifying the unrealistic values directly, but no longer requires you to directly examine each observation.

# Replacing values using formulas

Another way to approach this problem is to use a formula to specify the range of acceptable values.
This is particularly useful when dealing with non-integer values, where the colon operator (`:`) will not work:

```{r}
23 %in% 18:122
```

but

```{r}
23.5 %in% 18:122
```

Formulas in `fauxnaif` are based on the formula syntax used in `rlang` and `purrr`.
They are introduced with a tilde (`~`) and indicate each observation with a dot (`.`).

To clean the age variable, we will need two formulas.
One will replace values less than 18 and another will replace values greater than 122:

```{r}
faux_census$age %>% na_if(~ . < 18, ~ . > 122)
```

## Using relational operators from other packages

If you really want to get this down to a single argument, you can use more advanced relational operators provided by packages like `intrval`, `inops`, or `invctr`.

For example, `intrval`'s closed interval operator (`%[]%`) allows you to check if a value is between two values, even if it is not an integer:

```{r}
library(intrval)

23.5 %[]% c(18, 122)
```

With this, we can clean the age variable using only one formula argument:

```{r}
faux_census$age %>% na_if_not(~ . %[]% c(18, 122))
```

or 

```{r}
faux_census$age %>% na_if(~ . %][% c(18, 122))
```

## Using formulas for non-numeric variables

Formulas are not only useful when dealing with numeric variables.
While it's straightforward to use relational operators to specify replacements in numeric variables, we can also use more complex formulas to handle other data types.

Let's take a look at the religion variable:

```{r}
faux_census$religion
```

While there are a few things we might want to clean in this variable, one clear issue is the respondent who did not answer the question but instead used the space to give an opinion: "Religion is the opiate of the people".

We could use the most basic form of `na_if()` to simply remove this answer:

```{r}
faux_census$religion %>% na_if("Religion is the opiate of the people")
```

But in a larger analysis, we may prefer to have a simple rule for excluding answers.
Perhaps we decide that answers longer than 25 characters are unlikely to be genuine.
In that case, we can use a formula operating on the number of characters (`nchar(.)`) in a response:

```{r}
faux_census$religion %>% na_if(~ nchar(.) > 25)
```

# Replacing values using functions

Finally, there are cases when we can use a simple function to replace values.

Returning to the income variable, we know that `NA` is indicated using the largest value.
Rather than specifying it directly, we can simply tell `fauxnaif` to replace the variable's maximum value:

```{r}
faux_census$income %>% na_if(max)
```

We can do the same with the age variable, where both the lowest and highest values are unrealistic:

```{r}
faux_census$age %>% na_if(min, max)
```

But beware!
If no respondent had given an unrealistic answer, replacing the minimum or maximum values could result in the loss of real data!
It is often better to use more complicated formulas than simpler functions for your replacements.

# Replacing values in data frames

Often in data analysis, we prefer to work within a single data frame than operating on individual vectors.
`fauxnaif` is built to handle this use case.

A simple solution is to use `na_if()` or `na_if_not()` within `dplyr`'s `mutate()` function:

```{r}
faux_census %>% dplyr::mutate(income = na_if(income, 9999999))
```

However, you can also pass a data frame directly into one of `fauxnaif`'s `na_if_at()`.
This function takes the column to operate on as an input in addition to the value(s) to be replaced:

```{r}
faux_census %>% na_if_at("income", 9999999)
```

`na_if_not_at()` operates similarly but applies the logic of `na_if_not()`:

```{r}
faux_census %>% na_if_not_at("age", 18:122)
```

# Replacing values in multiple columns

Sometimes, the same replacement function can be used in multiple columns.
Here, the respondent who didn't give a real answer to the religion question seemed to do the same with the gender and race questions.
You can specify multiple columns to `na_if_at()` is you would like to make replacements based on the same criteria:

```{r}
faux_census %>% na_if_at(c("religion", "gender", "race"), ~ nchar(.) > 25)
```

`na_if_at()` is based on `dplyr`'s `mutate_at()`, meaning it can also work with any of `tidyselect`'s select helpers.

## Replacing values using a predicate function

Rather than specifying columns manually, we can also select columns using a predicate function with `na_if_if()`.

For example, we may want to remove strings of 9s in any numeric column:

```{r}
faux_census %>% na_if_if(is.numeric, ~ grepl("999*", as.character(.)))
```

## Replacing values in all columns

While this replacement was intended for three specific columns, no variable contains a legitimate answer longer than 25 characters.
In this case, rather than specifying the variable of interest, we can simply use `na_if_all()` to make the replacement in all columns:

```{r}
faux_census %>% na_if_all(~ nchar(.) > 25)
```

# Putting it all together

In a data analysis pipeline, we can combine several `fauxnaif` steps to produce a usable dataset.
Combining our interval check for age, our check for strings of 9s in numeric variables, and our check for long responses in character variables, we can yield much cleaner data:

```{r}
faux_census %>%
  na_if_not_at("age", 18:122) %>%
  na_if_if(is.numeric, ~ grepl("999*", as.character(.))) %>%
  na_if_all(~ nchar(.) > 25)
```

